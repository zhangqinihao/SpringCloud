分布式系统面临的问题
复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。


一般情况对于服务依赖的保护主要有3中解决方案：
 
（1）熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。
     放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，
     不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
 
（2）隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。
     例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，
     则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，
     对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。
 
（3）限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。
     限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，
     不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，
     因为没有被限流的请求依然有可能造成雪崩效应。
     
============================================================================================================
服务降级
服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback

哪些情况会触发降级?
程序运行异常
超时
服务熔断触发服务降级
线程池/信号量打满也会导致服务降级



服务熔断?
类比保险丝达到最大服务访问后，
直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示

服务的降级->进而熔断->恢复调用链路

服务限流 ?
秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行
项目 cloud-provider-hystrix-payment8001  7001  


成功 http://localhost:8001/payment/hystrix/ok/31

失败 http://localhost:8001/payment/hystrix/timeout/31

以上述为根基平台，从正确->错误->降级熔断->恢复
=======================================================================
开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务

http://jmeter.apache.org/download_jmeter.cgi
下载 Binaries zip（win版本）
找到jmeter下的bin目录，打开jmeter.properties 文件

第三十七行（新版39行）修改为

language=zh_CN

去掉前面的#，以后打开就是中文界面了

看演示结果
两个都在自己转圈圈
结论:上面还是服务提供者8001自己测试，
假如此时外部的消费者80也来访问，那消费者只能干等，
最终导致消费端80不满意，服务端8001直接被拖死
====================================
新建 
cloud-consumer-feign-hystrix-order80

正常测试 http://localhost/consumer/payment/hystrix/ok/31
2W个线程压8001
http://localhost/consumer/payment/hystrix/timeout/31
消费者80，呜呜呜


故障现象和导致原因
8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕
80此时调用8001，客户端访问响应缓慢，转圈圈
